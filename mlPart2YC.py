{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\ProgramData\\Anaconda3\\envs\\ML\\lib\\site-packages\\ipykernel\\ipkernel.py:287: DeprecationWarning: `should_run_async` will not call `transform_cell` automatically in the future. Please pass the result to `transformed_cell` argument and any exception that happen during thetransform in `preprocessing_exc_tuple` in IPython 7.17 and above.\n",
      "  and should_run_async(code)\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd  \n",
    "import numpy as np  \n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.pipeline import Pipeline, FeatureUnion \n",
    "from sklearn.base import BaseEstimator, TransformerMixin \n",
    "from sklearn.compose import ColumnTransformer\n",
    "from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV, KFold, RandomizedSearchCV \n",
    "from sklearn.linear_model import Perceptron, LogisticRegressionCV, RidgeClassifierCV, SGDClassifier, PassiveAggressiveClassifier, Lasso\n",
    "from sklearn.metrics import mean_squared_error, r2_score, accuracy_score,mean_absolute_error, confusion_matrix, silhouette_score\n",
    "from sklearn.metrics import roc_auc_score,roc_curve, auc, classification_report,precision_score,recall_score,log_loss,f1_score\n",
    "from sklearn.feature_selection import RFE\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.naive_bayes import GaussianNB, BernoulliNB, ComplementNB\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.tree import DecisionTreeClassifier\n",
    "import xgboost as xgb\n",
    "from xgboost import XGBClassifier\n",
    "from scipy.stats import uniform, randint\n",
    "from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, ExtraTreesClassifier, BaggingClassifier, VotingClassifier, AdaBoostClassifier\n",
    "from bayes_opt import BayesianOptimization\n",
    "from lightgbm import LGBMClassifier\n",
    "from imblearn.over_sampling import SMOTE\n",
    "from sklearn import tree\n",
    "from sklearn.model_selection import GridSearchCV, cross_val_score, StratifiedKFold\n",
    "from sklearn.preprocessing import StandardScaler, Normalizer, MinMaxScaler, LabelEncoder, OneHotEncoder,OrdinalEncoder\n",
    "from sklearn.preprocessing import MaxAbsScaler, RobustScaler, QuantileTransformer, PowerTransformer,minmax_scale,PolynomialFeatures\n",
    "from sklearn.svm import SVC, LinearSVC\n",
    "from sklearn.kernel_approximation import RBFSampler\n",
    "from sklearn import tree\n",
    "import pandas_bokeh\n",
    "from sklearn.decomposition import PCA,KernelPCA\n",
    "from sklearn.calibration import CalibratedClassifierCV\n",
    "from numpy import mean, std\n",
    "import pandas.testing as tm\n",
    "from scipy import stats\n",
    "from sklearn.gaussian_process import GaussianProcessClassifier\n",
    "from sklearn.neural_network import MLPClassifier\n",
    "from sklearn.inspection import permutation_importance\n",
    "from sklearn.tree import ExtraTreeClassifier\n",
    "from sklearn.experimental import enable_iterative_imputer \n",
    "from sklearn.impute import IterativeImputer, SimpleImputer, KNNImputer\n",
    "\n",
    "from yellowbrick.features import PCA as PCA_YB\n",
    "from yellowbrick.features.radviz import RadViz\n",
    "from yellowbrick.features import pca_decomposition\n",
    "from yellowbrick.features import Manifold\n",
    "from yellowbrick.features import JointPlotVisualizer\n",
    "from yellowbrick.classifier import ClassificationReport\n",
    "from yellowbrick.classifier import PrecisionRecallCurve\n",
    "from yellowbrick.classifier import ClassPredictionError\n",
    "from yellowbrick.model_selection import LearningCurve\n",
    "from yellowbrick.model_selection import CVScores\n",
    "from yellowbrick.model_selection import FeatureImportances\n",
    "from yellowbrick.features import ParallelCoordinates\n",
    "from yellowbrick.model_selection import RFECV\n",
    "from yellowbrick.classifier import ROCAUC\n",
    "\n",
    "\n",
    "#other\n",
    "from math import sqrt\n",
    "import inspect\n",
    "from matplotlib.font_manager import FontProperties\n",
    "from scipy.stats import loguniform, uniform\n",
    "from bokeh import io\n",
    "import datetime\n",
    "from imblearn.over_sampling import RandomOverSampler\n",
    "from imblearn.under_sampling import RandomUnderSampler\n",
    "import eli5\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index(['ID', 'Year_Birth', 'Education', 'Income', 'Kidhome', 'Teenhome',\n",
      "       'Dt_Customer', 'Recency', 'MntWines', 'MntFruits', 'MntMeatProducts',\n",
      "       'MntFishProducts', 'MntSweetProducts', 'MntGoldProds',\n",
      "       'NumDealsPurchases', 'NumWebPurchases', 'NumCatalogPurchases',\n",
      "       'NumStorePurchases', 'NumWebVisitsMonth', 'AcceptedCmp3',\n",
      "       'AcceptedCmp4', 'AcceptedCmp5', 'AcceptedCmp1', 'AcceptedCmp2',\n",
      "       'Complain', 'Z_CostContact', 'Z_Revenue', 'Response', 'Marital_Absurd',\n",
      "       'Marital_Alone', 'Marital_Divorced', 'Marital_Married',\n",
      "       'Marital_Single', 'Marital_Together', 'Marital_Widow', 'Marital_YOLO'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "DATASET_URL = \"https://gist.githubusercontent.com/YHYeoh/ad1a7f7170c72d621d05a70637540152/raw/5a6059c199e2c46d2f3d258f03d93cfea98e2749/marketing_campaign.csv\"\n",
    "data = pd.read_csv(DATASET_URL, sep = ';')\n",
    "\n",
    "education_order = [['Basic', 'Graduation', 'Master', '2n Cycle', 'PhD']]\n",
    "ordinal_encoder = OrdinalEncoder(categories=education_order)\n",
    "\n",
    "data[\"Education\"] = (ordinal_encoder.fit_transform(data[\"Education\"].values.reshape(-1, 1))).astype(int)\n",
    "# print(ordinal_encoder.categories_)\n",
    "\n",
    "#encode categorical column\n",
    "categorical = ['Marital_Status']\n",
    "marital_status_ohe = pd.get_dummies(data.Marital_Status,prefix=\"Marital\")\n",
    "data = data.join(marital_status_ohe)\n",
    "\n",
    "#drop original column after encoding\n",
    "data.drop(['Marital_Status'], axis = 1,inplace = True)\n",
    "\n",
    "print(data.columns)\n",
    "\n",
    "tunable_cols = [\"Year_Birth\", \"Income\",\"Dt_Customer\"]\n",
    "\n",
    "\n",
    "y = data.Response\n",
    "X = data.drop(\"Response\",axis=1)\n",
    "\n",
    "numerical_bool_col = [x for x in data.columns if data[x].isin([0,1]).all()] # print(numerical_bool_col)\n",
    "numerical_scalable_col = [x for x in data.columns if x not in numerical_bool_col]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\ProgramData\\Anaconda3\\envs\\ML\\lib\\site-packages\\ipykernel\\ipkernel.py:287: DeprecationWarning: `should_run_async` will not call `transform_cell` automatically in the future. Please pass the result to `transformed_cell` argument and any exception that happen during thetransform in `preprocessing_exc_tuple` in IPython 7.17 and above.\n",
      "  and should_run_async(code)\n"
     ]
    }
   ],
   "source": [
    "# import pandas as pd\n",
    "# from sklearn.experimental import enable_iterative_imputer\n",
    "# from sklearn.impute import IterativeImputer, SimpleImputer, KNNImputer\n",
    "\n",
    "# from sklearn.preprocessing import OrdinalEncoder\n",
    "# import numba\n",
    "# import numpy as np\n",
    "# from scipy import stats\n",
    "\n",
    "def getKeyVal(inDict):\n",
    "  for i in inDict:\n",
    "    key=i\n",
    "    val= inDict[i]\n",
    "  return key,val\n",
    "\n",
    "def getIterativeImputedIncome(data):\n",
    "  imr = IterativeImputer(random_state=42, max_iter=100, min_value= data['Income'].min())\n",
    "  imr = imr.fit(data[['Income']])\n",
    "  data['Income'] = imr.transform(data[['Income']]).ravel()\n",
    "  return data\n",
    "\n",
    "def getKNNImputedIncome(data):\n",
    "\timputer = KNNImputer(n_neighbors=5, weights='uniform', metric='nan_euclidean')\n",
    "\tdata = pd.DataFrame(imputer.fit_transform(data), columns=data.columns)\n",
    "\treturn data\n",
    "\n",
    "def getAgeFromDateBirth(data):\n",
    "\tyear = datetime.datetime.now().year\n",
    "\tdata['Year_Birth'] = data['Year_Birth'].apply(lambda x : year - x )\n",
    "\treturn data\n",
    "\n",
    "def extractFromDate(data):\n",
    "\tdata['enroll_year'] = pd.DatetimeIndex(data.Dt_Customer).year\n",
    "\tdata['enroll_month'] = pd.DatetimeIndex(data.Dt_Customer).month\n",
    "\tdata['enroll_day'] = pd.DatetimeIndex(data.Dt_Customer).day\n",
    "\tdata.drop(['Dt_Customer'], axis = 1, inplace= True)\n",
    "\treturn data\n",
    "\n",
    "def convertToDays(data):\n",
    "\tvfunc = np.vectorize(lambda x: (datetime.datetime.now() - x).days)\n",
    "\tdata['Dt_Customer'] = vfunc(pd.DatetimeIndex(data.Dt_Customer).to_pydatetime())\n",
    "\treturn data\n",
    "\n",
    "def getBinnedIncome(data):\n",
    "\tdata['Income'] = pd.cut(data['Income'], bins=[0, 15000, 60000, 110000, 700000], labels=False, precision=0).convert_dtypes()\n",
    "\treturn data\n",
    "\n",
    "def getNormalizedIncome(data):\n",
    "    \n",
    "\tdata = data[(np.abs(stats.zscore(data[['Income']])) < 3)]\n",
    "\treturn data\n",
    "\n",
    "def getNormalizedAndBinnedIncome(data):\n",
    "\tdata = data[(np.abs(stats.zscore(data[['Income']])) < 3)]\n",
    "\tdata['Income'] = pd.cut(data['Income'], bins=[0, 15000, 60000, 110000, 700000], labels=False, precision=0).convert_dtypes()\n",
    "\treturn data\n",
    "\n",
    "\n",
    "def getOverSamplingData(x,y):\n",
    "    oversampler = RandomOverSampler(sampling_strategy=0.5)\n",
    "    x,y = oversampler.fit_resample(x, y)\n",
    "    return (x,y)\n",
    "\n",
    "\n",
    "def getUnderSamplingData(x,y):\n",
    "    undersampler = RandomUnderSampler(sampling_strategy='majority')\n",
    "    x,y = undersampler.fit_resample(x, y)\n",
    "    return (x,y)\n",
    "\n",
    "def getHypeYearBirth(data):\n",
    "\thyper_year_birth = [\n",
    "    {'Not age engineering':data},\n",
    "\t\t{'Age':getAgeFromDateBirth(data.copy())}\n",
    "\t]\n",
    "\treturn hyper_year_birth\n",
    "\n",
    "hyper_dt_customer = [\n",
    "\t{'extractFromDate':extractFromDate(data.copy())},\n",
    "\t{'convertToDays':convertToDays(data.copy())}\n",
    "]\n",
    "\n",
    "def getPreprocessingIncome(data):\n",
    "\tpreprocessing_income = [\n",
    "    {'getIterativeImputedIncome':getIterativeImputedIncome(data.copy())},\n",
    "\t\t{'getKNNImputedIncome':getKNNImputedIncome(data.copy())},\n",
    "\t\t{'fillNa method = ffill':data.copy().fillna(method = \"ffill\")}, #ffill\n",
    "\t\t{'fillNa method = bfill':data.copy().fillna(method = \"bfill\")}, #bfill\n",
    "\t\t{'mean imputed':data.copy().fillna(data.mean())}, #mean imputed\n",
    "\t\t{'median imputed':data.copy().fillna(data.median())}, #median imputed\n",
    "\t\t{'Income dropped':data.copy().dropna(subset=['Income'])}\n",
    "\t]\n",
    "\treturn preprocessing_income\n",
    "\n",
    "def getHypeIncome(data):\n",
    "\thyper_income = [\n",
    "  {'No income engineering':data},\n",
    "\t{'Binned Income':getBinnedIncome(data.copy())},\n",
    "\t{'Normalized Income':getNormalizedIncome(data.copy())},\n",
    "\t{'Binned and Normalized Income':getNormalizedAndBinnedIncome(data.copy())}\n",
    "\t]\n",
    "\treturn hyper_income\n",
    "\n",
    "\n",
    "def getDataSampling(x,y):\n",
    "\thyper_oversampling = [\n",
    "  {'No data sampling':(x,y)},\n",
    "\t{'Under sampling':getUnderSamplingData(x,y)},\n",
    "\t{'Over sampling':getOverSamplingData(x,y)},\n",
    "\t]\n",
    "\treturn hyper_oversampling\n",
    "\n",
    "\n",
    "# hyperparams = {\n",
    "# \t\"Year_Birth\":[ data['Year_Birth'], getAgeFromDateBirth(data.copy())],\t\n",
    "# \t\"Income\": [data['Income'], getBinnedIncome(data['Income']), getNormalizedIncome()]\n",
    "# }"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [],
   "source": [
    "def hasmethod(obj, name):\n",
    "\treturn inspect.ismethod(getattr(obj, name, None))\n",
    "\n",
    "def setupPreprocessPipeline(scaler,numerical_no_bool):\n",
    "\tss = Pipeline(steps=[('scaler',scaler)])\n",
    "\t#ohe = Pipeline(steps=[('ohe', OneHotEncoder(handle_unknown = 'ignore'))])\n",
    "\tpreprocess = ColumnTransformer(\n",
    "                    transformers=[\n",
    "                        ('cont', ss, numerical_no_bool)\n",
    "                        #('cat', ohe, categorical),\n",
    "                        #('le', le, ordinal),\n",
    "                        ],remainder='passthrough')\n",
    "\treturn preprocess\n",
    "\n",
    "\n",
    "\n",
    "    \n",
    "def overallClassificationReport(model,classes):\n",
    "\tvisualizer = ClassificationReport(model, classes=classes, support=True) #might can change\n",
    "\tvisualizer.fit(X_train, y_train)        # Fit the visualizer and the model\n",
    "\tif(model.__class__.__name__ == \"XGBClassifier\"): #special treatment for xgboost as it reordered column\n",
    "\t\tmodel.fit(X_train, y_train)\n",
    "\t\treorderedColumn = model.get_booster().feature_names\n",
    "\t\treordered_Xtest = X_test[reorderedColumn] #reorderColumn\n",
    "\t\tvisualizer.score(X_test, y_test)        \n",
    "\t\tvisualizer.show()\n",
    "\t\treturn\n",
    "\tvisualizer.score(X_test, y_test)        # Evaluate the model on the test data\n",
    "\tvisualizer.show()\n",
    "\n",
    "\n",
    "def overall_feature_importance(model,X_train,y_train):\n",
    "\tlabels = list(map(lambda s: s.title(), X.columns))\n",
    "\tviz = FeatureImportances(model, labels=labels,encoder={1: 'yes',0: 'no'}, relative=False, topn = 8)\n",
    "\tviz.fit(X, y)\n",
    "\tviz.show()\n",
    "\n",
    "def has_feature_imp(classifier):\n",
    "\tstatus = False\n",
    "\tif (hasattr(classifier,'coef_')):\n",
    "\t\tstatus = True\n",
    "\telif (hasattr(classifier,'coefs_')):\n",
    "\t\tstatus = True\n",
    "\telif (hasattr(classifier,'feature_importances_')):\n",
    "\t\tstatus = True\n",
    "\tprint(\"Cannot extract feature importance, skipping\")\n",
    "\treturn status\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cross_validate(classifier, cv,X_train,y_train,dtColumnStatus\n",
    "                   ,incomePreproStatus,IncomeEngiStatus,yearProcessStatus,dataSamplingStatus,numerical_no_bool):\n",
    "\tscalers = [StandardScaler(),MinMaxScaler(),MaxAbsScaler(), RobustScaler(),QuantileTransformer()]\n",
    "\ttrain_acc = []\n",
    "\ttest_acc = []\n",
    "\tmean = []\n",
    "\tresult = []\n",
    "\tfor scaler in scalers:\n",
    "\t\tpreprocess = setupPreprocessPipeline(scaler,numerical_no_bool)\n",
    "\t\tpipeline = Pipeline(steps=[\n",
    "\t        ('preprocess', preprocess),\n",
    "\t        ('classifier', classifier)\n",
    "\t\t])\n",
    "\n",
    "\t\ttrain_acc = []\n",
    "\t\ttest_acc = []\n",
    "\t\ttrain_recall = []\n",
    "\t\ttest_recall = []\n",
    "\t\ttrain_precision = []\n",
    "\t\ttest_precision = []\n",
    "\t\ttrain_f1 = []\n",
    "\t\ttest_f1 = []\n",
    "\t\ttrain_auc_roc = []\n",
    "\t\ttest_auc_roc = []\n",
    "\t\tmean = []\n",
    "\t\t\n",
    "\t\tfor train_ind, val_ind in cv.split(X_train, y_train):\n",
    "\t\t\tX_t, y_t = X_train.iloc[train_ind], y_train.iloc[train_ind]\n",
    "\t\t\tpipeline.fit(X_t, y_t)\n",
    "\t\t\ty_hat_t = pipeline.predict(X_t)\n",
    "\t\t\ttrain_acc.append(accuracy_score(y_t, y_hat_t))\n",
    "\t\t\ttrain_recall.append(recall_score(y_t, y_hat_t))\n",
    "\t\t\ttrain_precision.append(precision_score(y_t, y_hat_t))\n",
    "\t\t\ttrain_f1.append(f1_score(y_t, y_hat_t))\n",
    "\t\t\ttrain_auc_roc.append(roc_auc_score(y_t, y_hat_t))\n",
    "\t\t\tX_val, y_val = X_train.iloc[val_ind], y_train.iloc[val_ind] \n",
    "\t\t\ty_hat_val = pipeline.predict(X_val)\n",
    "\t\t\ttest_acc.append(accuracy_score(y_val, y_hat_val))\n",
    "\t\t\ttest_recall.append(recall_score(y_val, y_hat_val))\n",
    "\t\t\ttest_precision.append(precision_score(y_val, y_hat_val))\n",
    "\t\t\ttest_f1.append(f1_score(y_val, y_hat_val))\n",
    "\t\t\ttest_auc_roc.append(roc_auc_score(y_val, y_hat_val))\n",
    "            \n",
    "\t\tmodel_result.append({\n",
    "            'classifier':classifier.__class__.__name__,\n",
    "            'scalerName':scaler.__class__.__name__,\n",
    "            'dataSampling':dataSamplingStatus,\n",
    "            'dtColumn':dtColumnStatus,\n",
    "            'incomePreprocessing':incomePreproStatus,\n",
    "            'IncomeEngineering':IncomeEngiStatus,\n",
    "            'yearProcess':yearProcessStatus,\n",
    "            'train_accuracy':np.mean(train_acc),\n",
    "            'test_accuracy':np.mean(test_acc),\n",
    "            'train_recall':np.mean(train_recall),\n",
    "            'test_recall':np.mean(test_recall),\n",
    "            'train_precision':np.mean(train_precision),\n",
    "            'test_precision':np.mean(test_precision),\n",
    "            'train_f1':np.mean(train_f1),\n",
    "            'test_f1':np.mean(test_f1),\n",
    "            'train_auc_roc':np.mean(train_auc_roc),\n",
    "            'test_auc_roc':np.mean(test_auc_roc)\n",
    "        })\n",
    "\n",
    "\treturn result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [],
   "source": [
    "models = [\n",
    "\t#Lasso(),\n",
    "# \tSGDClassifier(max_iter = 1000, tol=1e-3,penalty = \"elasticnet\"),\n",
    "# \tLinearSVC(), \n",
    "# \tGaussianProcessClassifier(),\n",
    "# \tExtraTreesClassifier(), \n",
    "# # \tBernoulliNB(),\n",
    "\tLogisticRegressionCV(max_iter= 1200), \n",
    "# \tRidgeClassifierCV(),\n",
    "\tSVC(kernel = 'linear',max_iter= -1), \n",
    "# \tPerceptron(),\n",
    "# \tPassiveAggressiveClassifier(), \n",
    "# \tDecisionTreeClassifier(), #no coef \n",
    "# \tKNeighborsClassifier(),#no feat_import, use permutation_importance \n",
    "# \tGaussianNB(), #no feat_import, use permutation_importance \n",
    "\tLGBMClassifier(),#no coef \n",
    "\tRandomForestClassifier(), #no coef \n",
    "# \tGradientBoostingClassifier(),#no coef \n",
    "# \tPassiveAggressiveClassifier(), \n",
    "# \tExtraTreesClassifier(), #no coef \n",
    "\tXGBClassifier(),\n",
    "# \tAdaBoostClassifier(), #no coef\n",
    "# \tMLPClassifier() #mlp not working\n",
    "\t]\n",
    "tunable_cols = [\"Year_Birth\", \"Income\",\"Dt_Customer\"]\n",
    "model_result= []\n",
    "classes = [\"no\", \"yes\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "problemSet=None;\n",
    "counter=0;\n",
    "for processed_dt_cust in hyper_dt_customer:\n",
    "  dtColumnMethod,data= getKeyVal(processed_dt_cust)\n",
    "  for preprocessed_income in getPreprocessingIncome(data):\n",
    "    incomePreprocessMethod,data= getKeyVal(preprocessed_income)\n",
    "    for processed_income_col in getHypeIncome(data):\n",
    "      incomeEngineeringMethod,data= getKeyVal(processed_income_col)\n",
    "      for processed_year_birth in getHypeYearBirth(data):\n",
    "        processYearMethod,data = getKeyVal(processed_year_birth) # print(data)\n",
    "        numerical_bool_col = [x for x in data.columns if data[x].isin([0,1]).all()] # print(numerical_bool_col)\n",
    "        numerical_scalable_col = [x for x in data.columns if x not in numerical_bool_col]\n",
    "        y = data.Response # print(y.value_counts())\n",
    "        X = data.drop(['Response'], axis=1)\n",
    "        #should auto drop columns based on pearson correlation , feature importance\n",
    "        #X.drop(['NumStorePurchases','NumCatalogPurchases','MntFruits','MntFishProducts','MntSweetProducts','MntWines'], axis = 1, inplace = True)\n",
    "        \n",
    "\n",
    "    #             print(\"Dt                : \",dtColumnMethod,\"\\n\")\n",
    "    #             print(\"Preprocess Income : \",incomePreprocessMethod,\"\\n\")\n",
    "    #             print(\"Income Engineering: \",incomeEngineeringMethod,\"\\n\")\n",
    "    #             print(\"Process Year      : \",processYearMethod,\"\\n\") # print(numerical_scalable_col) # print(data.info())\n",
    "    #             print(\"Data Sampling     : \",dataSamplingDesc,\"\\n\")\n",
    "              \n",
    "      \n",
    "        for model in models:\n",
    "            x_dropped_data = X.drop([x for x in X.columns if x not in classifier_columns[model.__class__.__name__]],axis = 1)\n",
    "            nummerical_no_bool = [x for x in numerical_scalable_col if x in x_dropped_data.columns]\n",
    "            \n",
    "            X_train, X_test, y_train, y_test = train_test_split(x_dropped_data,y, test_size=0.25, random_state=42)\n",
    "            for dataSamplingMethod in getDataSampling(X_train,y_train):\n",
    "              dataSamplingDesc,data= getKeyVal(dataSamplingMethod)\n",
    "              X_train,y_train = data\n",
    "#             print(X_train.isnull().values.any(),y_train.isnull().values.any(),\"\\n\")\n",
    "              if(X_train.isnull().values.any()==True):\n",
    "                  problemSet = X_train\n",
    "                  print(X_train.isnull())\n",
    "                  break\n",
    "              counter+=1\n",
    "              if(counter%100==0):\n",
    "                  print(\"Counter : \",counter)\n",
    "              model_result.append(cross_validate(model,StratifiedKFold(),X_train,y_train,dtColumnMethod,incomePreprocessMethod\n",
    "                                                    ,incomeEngineeringMethod,processYearMethod,dataSamplingDesc,nummerical_no_bool))\n",
    "  #                 overallClassificationReport(model,classes)\n",
    "#                 if hasmethod(model, 'predict_proba'):\n",
    "#                     ROC_Curve_Plot(model,X_test,y_test,\"Overall \"+model.__class__.__name__)\n",
    "#                 if has_feature_imp(model) :\n",
    "#                     overall_feature_importance(model,X_train, y_train)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "resultDF = pd.DataFrame.from_records(model_result,columns=['classifier','scalerName','dataSampling','dtColumn'\n",
    "                                                           ,'incomePreprocessing','IncomeEngineering','yearProcess'\n",
    "                                                           ,'train_accuracy','test_accuracy','train_recall','test_recall'\n",
    "                                                           ,'train_precision','test_precision','train_f1','test_f1',\n",
    "                                                          'train_roc_auc','test_roc_auc'])\n",
    "resultDF=resultDF.dropna(how='all')\n",
    "\n",
    "# roc_auc\n",
    "# f1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "resultDF.isnull().values.any()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "accColumn=['classifier','scalerName','dataSampling','dtColumn','incomePreprocessing','IncomeEngineering','yearProcess','train_accuracy','test_accuracy']\n",
    "resultDF[accColumn].sort_values('test_accuracy',ascending=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "recallColumn=['classifier','scalerName','dataSampling','dtColumn','incomePreprocessing','IncomeEngineering','yearProcess','train_recall','test_recall']\n",
    "resultDF[recallColumn].sort_values('test_recall',ascending=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "precColumn=['classifier','scalerName','dataSampling','dtColumn','incomePreprocessing','IncomeEngineering','yearProcess','train_precision','test_precision']\n",
    "resultDF[precColumn].sort_values('test_precision',ascending=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "f1Column=['classifier','scalerName','dataSampling','dtColumn','incomePreprocessing','IncomeEngineering','yearProcess','train_f1','test_f1']\n",
    "resultDF[f1Column].sort_values('test_f1',ascending=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "roc_aucColumn=['classifier','scalerName','dataSampling','dtColumn','incomePreprocessing','IncomeEngineering','yearProcess','train_roc_auc','test_roc_auc']\n",
    "resultDF[roc_aucColumn].sort_values('test_roc_auc',ascending=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.e-03, 1.e-02, 1.e-01, 1.e+00, 1.e+01, 1.e+02, 1.e+03])"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [],
   "source": [
    "#svc xgb, rfc, lgbm, logistic\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "scoring = 'f1'\n",
    "fold=10\n",
    "# featureNumList = list(range(1,X_train.shape[1]))\n",
    "modelsWithParam = [\n",
    "         { \n",
    "        'model':LogisticRegression(),'param':{'C': np.logspace(-3,3,7),#100,10,1, 0.1, 0.01, 0.001\n",
    "#                                  'fit_intercept':[True,False],\n",
    "#                                  'dual':[True,False],\n",
    "#                                  'penalty':['l2'],\n",
    "#                                  'max_iter':list(range(100,1000,100)),#[50,100,500,1000,2000,4000,8000]\n",
    "#                                  'solver':['newton-cg', 'lbfgs', 'liblinear', 'sag'],\n",
    "        }},\n",
    "    {\n",
    "        'model':LGBMClassifier(),'param':{\n",
    "        'boosting_type':[\"gbdt\",\"dart\",\"goss\",\"rf\"],\n",
    "        'metric':['binary_logloss'],\n",
    "#         'sub_feature':list(np.arange(0.1,1,10)),\n",
    "#         'num_leaves':list(range(10,50,10)),\n",
    "#         'learning_rate': [1,0.1,0.01,0.005,0.001],\n",
    "#         'n_estimators': list(range(100,1000,100)),\n",
    "#         'min_data':[50],\n",
    "#         'max_depth': list(range(5,20,5)),\n",
    "#         'min_split_gain':list(np.arange(0.1,1,10)),\n",
    "#         'random_state': [42]\n",
    "    }},\n",
    "    {\n",
    "        'model':RandomForestClassifier(),'param':{\n",
    "            'bootstrap': [True, False],\n",
    "#              'max_depth': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, None],\n",
    "#              'max_features': ['auto', 'sqrt'],\n",
    "#              'min_samples_leaf': [1, 2, 4],\n",
    "#              'min_samples_split': [2, 5, 10],\n",
    "#              'n_estimators': [200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000]}\n",
    "    }},\n",
    "    {\n",
    "        'model':XGBClassifier(),'param':{\n",
    "            'n_estimators': [400] #, 700, 1000],\n",
    "#             'colsample_bytree': [0.7, 0.8],\n",
    "#             'max_depth': [15,20,25],\n",
    "#             'reg_alpha': [1.1, 1.2, 1.3],\n",
    "#             'reg_lambda': [1.1, 1.2, 1.3],\n",
    "#             'subsample': [0.7, 0.8, 0.9]\n",
    "        }\n",
    "    },\n",
    "    {\n",
    "            \n",
    "        'model':SVC(),'param':{\n",
    "         'C': [ 1,0.1] #,10, 100, 1000],  \n",
    "#         'gamma': [0.0001,0.00001], \n",
    "#         'kernel': ['linear', 'rbf'],\n",
    "#         'random_state': [42] \n",
    "    }}\n",
    "    \n",
    "    \n",
    "    \n",
    "#     { split svc into 2 as svc poly and non-poly kernel has\n",
    "#         #different parameter\n",
    "#         'model':SVC(),'param':{\n",
    "#         'C': [0.1, 1, 10, 100, 1000],  \n",
    "#         'gamma': [1,0.1,0.01,0.005,0.001,0.0005,0.0001], \n",
    "#         'kernel': ['poly'],\n",
    "#         'degree':list(range(3,10)),\n",
    "#         'random_state': [42],\n",
    "#     }}\n",
    "\n",
    "#         {\n",
    "#         'model':LogisticRegression(),'param':{'Cs': [[100,10,1, 0.1,0.05,0.001,0.0001]],#100,10,1, 0.1, 0.01, 0.001\n",
    "#                                  'fit_intercept':[True,False],\n",
    "#                                  'normalize':[True,False],\n",
    "#                                  'penalty':['elasticnet'],\n",
    "#                                  'penalty':[True],\n",
    "#                                  'max_iter':list(range(100,1000,100)),#[50,100,500,1000,2000,4000,8000]\n",
    "#                                  'solver':['saga'],\n",
    "#                                  'random_state':[42]\n",
    "#         }}\n",
    "]\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [],
   "source": [
    "#defines column to drop for each classifier\n",
    "classifier_columns = {\n",
    "\t\t\"SVC\":[\"AcceptedCmp2\",\"AcceptedCmp5\",\"MntSweetProducts\",\"Complain\",\"MntWines\",\"Year_Birth\",\"MntGoldProds\",\"NumDealsPurchases\"],\n",
    "\t\t\"LGBMClassifier\":[\"Kidhome\",\"MntWines\",\"Education\",\"Teenhome\",\"AcceptedCmp4\",\"MntFishProducts\",\"AcceptedCmp2\",\"AcceptedCmp5\"],\n",
    "\t\t\"RandomForestClassifier\":[\"Kidhome\",\"Teenhome\",\"Education\",\"MntWines\",\"MntFishProducts\",\"AcceptedCmp4\",\"AcceptedCmp5\",\"AcceptedCmp2\"],\n",
    "\t\t\"XGBClassifier\":[\"AcceptedCmp2\",\"AcceptedCmp5\",\"Complain\",\"Marital_Together\",\"Marital_Married\",\"NumDealsPurchases\",\"Kidhome\",\"Year_Birth\"],\n",
    "\t\t\"LogisticRegression\":[\"AcceptedCmp2\",\"AcceptedCmp5\",\"Complain\",\"AcceptedCmp1\",\"enroll_year\",\"Marital_Married\",\"Marital_Together\",\"Year_Birth\"]\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(2148, 100)\n",
      "(560, 100)\n",
      "{'model_name': 'LogisticRegression', 'test_score': 0.8375, 'best_score': 0.7681564245810055, 'best_model': LogisticRegression(C=100.0)}\n",
      "(2148, 100)\n",
      "(560, 100)\n",
      "{'model_name': 'LGBMClassifier', 'test_score': 0.8196428571428571, 'best_score': 0.9208566108007449, 'best_model': LGBMClassifier(metric='binary_logloss')}\n",
      "(2148, 100)\n",
      "(560, 100)\n",
      "{'model_name': 'RandomForestClassifier', 'test_score': 0.8071428571428572, 'best_score': 0.9166666666666667, 'best_model': RandomForestClassifier(bootstrap=False)}\n",
      "(2148, 100)\n",
      "(560, 100)\n",
      "[21:44:51] WARNING: C:/Users/Administrator/workspace/xgboost-win64_release_1.3.0/src/learner.cc:1061: Starting in XGBoost 1.3.0, the default evaluation metric used with the objective 'binary:logistic' was changed from 'error' to 'logloss'. Explicitly set eval_metric if you'd like to restore the old behavior.\n",
      "{'model_name': 'XGBClassifier', 'test_score': 0.7982142857142858, 'best_score': 0.8412476722532588, 'best_model': XGBClassifier(base_score=0.5, booster='gbtree', colsample_bylevel=1,\n",
      "              colsample_bynode=1, colsample_bytree=1, gamma=0, gpu_id=-1,\n",
      "              importance_type='gain', interaction_constraints='',\n",
      "              learning_rate=0.300000012, max_delta_step=0, max_depth=6,\n",
      "              min_child_weight=1, missing=nan, monotone_constraints='()',\n",
      "              n_estimators=400, n_jobs=4, num_parallel_tree=1, random_state=0,\n",
      "              reg_alpha=0, reg_lambda=1, scale_pos_weight=1, subsample=1,\n",
      "              tree_method='exact', validate_parameters=1, verbosity=None)}\n",
      "(2148, 100)\n",
      "(560, 100)\n",
      "{'model_name': 'SVC', 'test_score': 0.8392857142857143, 'best_score': 0.7518621973929236, 'best_model': SVC(C=1)}\n"
     ]
    }
   ],
   "source": [
    "#randomised search cv\n",
    "from sklearn.kernel_approximation import Nystroem\n",
    "scoring = \"accuracy\"\n",
    "fold=4\n",
    "def modelBestFit(item,X_trains,y_trains,X_tests,y_tests):\n",
    "    model = item['model']\n",
    "    paramGrid = item['param']\n",
    "    search = RandomizedSearchCV(estimator=model, param_distributions= paramGrid\n",
    "                                ,n_iter=200,n_jobs=-1,pre_dispatch='1*n_jobs'\n",
    "                                ,scoring = scoring,refit = True,cv=fold\n",
    "                                ,random_state=42)\n",
    "    search.fit(X_trains,y_trains.values)\n",
    "    test_score =search.score(X_tests,y_tests.values)\n",
    "    model_name = model.__class__.__name__\n",
    "    return {'model_name':model_name,'test_score':test_score,'best_score':search.best_score_,'best_model':search.best_estimator_}\n",
    "\n",
    "def bestModel(modelsAndParams):\n",
    "    modelPerformance = pd.DataFrame()\n",
    "    for item in modelsAndParams:\n",
    "        \n",
    "        model = item['model']\n",
    "        \n",
    "        x_copy = X.copy()\n",
    "        x_copy = x_copy.drop([x for x in x_copy.columns if x not in classifier_columns[model.__class__.__name__]],axis = 1)\n",
    "        \n",
    "        X_train, X_test, y_train, y_test = train_test_split(x_copy,y, test_size=0.25, random_state=42)\n",
    "        \n",
    "        X_train= X_train.fillna(method = \"ffill\")\n",
    "        X_test = X_test.fillna(method = \"ffill\")\n",
    "        \n",
    "        if('Dt_Customer' in x_copy.columns):\n",
    "            X_train = extractFromDate(X_train)\n",
    "            X_test = extractFromDate(X_test)\n",
    "        \n",
    "        if('Income' in x_copy.columns):\n",
    "            X_train = getNormalizedAndBinnedIncome(X_train)\n",
    "            X_test = getNormalizedAndBinnedIncome(X_test)\n",
    "        \n",
    "        y_train = y_train[y_train.index.isin(X_train.index)]\n",
    "        y_test = y_test[y_test.index.isin(X_test.index)]\n",
    "        oversampler = RandomOverSampler(sampling_strategy=0.5,random_state=42)\n",
    "        X_train,y_train = oversampler.fit_resample(X_train, y_train)\n",
    "        \n",
    "        qt = QuantileTransformer(random_state=42)\n",
    "        X_train = qt.fit_transform(X_train)\n",
    "        X_test = qt.transform(X_test)\n",
    "        \n",
    "        nystroem = Nystroem()\n",
    "        \n",
    "        X_train_transformed = nystroem.fit_transform(X_train)\n",
    "        X_test_transformed = nystroem.transform(X_test)\n",
    "\n",
    "        print(X_train_transformed.shape)\n",
    "        print(X_test_transformed.shape)\n",
    "\n",
    "        result = modelBestFit(item,X_train_transformed,y_train,X_test_transformed,y_test)\n",
    "        modelPerformance = modelPerformance.append(result,ignore_index=True)\n",
    "        print(result)\n",
    "        \n",
    "    modelPerformance.sort_values(by='test_score',ascending=False,inplace=True)\n",
    "    return modelPerformance\n",
    " \n",
    "result = bestModel(modelsWithParam)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import pickle\n",
    "import warnings\n",
    "\n",
    "def overallClassificationReport(model,classes,X_train,y_train,X_test,y_test):\n",
    "\tvisualizer = ClassificationReport(model, classes=classes, support=True) #might can change\n",
    "\tvisualizer.fit(X_train, y_train.values.reshape(-1, 1))        # Fit the visualizer and the model\n",
    "\tvisualizer.score(X_test, y_test.values)        # Evaluate the model on the test data\n",
    "\tvisualizer.show()\n",
    "def votingClassifierReport(classifiers,votingT,X_train,y_train,X_test,y_test):\n",
    "    warnings.filterwarnings(\"ignore\")\n",
    "    usableClassifier = []\n",
    "    if(votingT =='soft'):\n",
    "        for i in classifiers:\n",
    "            if hasattr(i[1],'predict_proba'):\n",
    "                usableClassifier.append(i)\n",
    "    else:\n",
    "        usableClassifier = classifiers\n",
    "    classes =['no','yes']\n",
    "    #majority voting\n",
    "    in_use_classifiers=\"\"\n",
    "    for i in usableClassifier:\n",
    "        in_use_classifiers = in_use_classifiers+\" \"+str(i[1].__class__.__name__)\n",
    "    print(\"Voting Type : \",votingT)\n",
    "    print(\"Classifiers: \"+in_use_classifiers)\n",
    "    voting = VotingClassifier(estimators=usableClassifier, voting=votingT)\n",
    "#     voting.train\n",
    "    pkl_filename = \"{}votingClassifier.pkl\".format(votingT)\n",
    "    if os.path.exists(pkl_filename):\n",
    "        with open(pkl_filename, 'rb') as file:  \n",
    "            voting = pickle.load(file)\n",
    "    else:\n",
    "        voting = voting.fit(X_train,y_train)\n",
    "    voting = voting.fit(X_train,y_train)\n",
    "    \n",
    "    with open(pkl_filename, 'wb') as file:\n",
    "        pickle.dump(voting, file)\n",
    "    overallClassificationReport(voting,classes,X_train,y_train,X_test,y_test)\n",
    "    warnings.filterwarnings(\"default\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [],
   "source": [
    "def softHardClassificationReport(result):\n",
    "    top_3 = result.sort_values(by='test_score',ascending=False).head(n=3)\n",
    "    top_3 = top_3.reset_index().drop('index',axis=1)\n",
    "    nofOfClassifier=3\n",
    "    classList = []\n",
    "    best_model_name = top_3['model_name'][0]\n",
    "    topColumns = classifier_columns[best_model_name]\n",
    "\n",
    "\n",
    "    x_copy = X.copy()\n",
    "    x_copy = x_copy.drop([x for x in x_copy.columns if x not in classifier_columns[best_model_name]],axis = 1)\n",
    "\n",
    "    X_train, X_test, y_train, y_test = train_test_split(x_copy,y, test_size=0.25, random_state=42)\n",
    "\n",
    "    X_train= X_train.fillna(method = \"ffill\")\n",
    "    X_test = X_test.fillna(method = \"ffill\")\n",
    "\n",
    "    if('Dt_Customer' in x_copy.columns):\n",
    "        X_train = extractFromDate(X_train)\n",
    "        X_test = extractFromDate(X_test)\n",
    "\n",
    "    if('Income' in x_copy.columns):\n",
    "        X_train = getNormalizedAndBinnedIncome(X_train)\n",
    "        X_test = getNormalizedAndBinnedIncome(X_test)\n",
    "\n",
    "    y_train = y_train[y_train.index.isin(X_train.index)]\n",
    "    y_test = y_test[y_test.index.isin(X_test.index)]\n",
    "    oversampler = RandomOverSampler(sampling_strategy=0.5,random_state=42)\n",
    "    X_train,y_train = oversampler.fit_resample(X_train, y_train)\n",
    "\n",
    "    qt = QuantileTransformer(random_state=42)\n",
    "    X_train = qt.fit_transform(X_train)\n",
    "    X_test = qt.transform(X_test)\n",
    "\n",
    "    nystroem = Nystroem()\n",
    "\n",
    "    X_train_transformed = nystroem.fit_transform(X_train)\n",
    "    X_test_transformed = nystroem.transform(X_test)\n",
    "\n",
    "\n",
    "    for i in range(nofOfClassifier):\n",
    "        model_name = top_3['model_name'][i]\n",
    "        model = top_3['best_model'][i]\n",
    "        classList.append((model_name,model))\n",
    "        votingOption=['hard','soft']\n",
    "\n",
    "    for voteType in votingOption:\n",
    "        votingClassifierReport(classList,voteType,X_train_transformed,y_train,X_test_transformed,y_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Voting Type :  hard\n",
      "Classifiers:  SVC LogisticRegression LGBMClassifier\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Voting Type :  soft\n",
      "Classifiers:  LogisticRegression LGBMClassifier\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "softHardClassificationReport(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Voting Type :  hard\n",
      "Classifiers:  SVC LogisticRegression LGBMClassifier\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'X_train' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-55-41c6386a5c50>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m \u001b[1;32mfor\u001b[0m \u001b[0mvoteType\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mvotingOption\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m     \u001b[0mvotingClassifierReport\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mclassList\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mvoteType\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<ipython-input-54-ae2341149d5f>\u001b[0m in \u001b[0;36mvotingClassifierReport\u001b[1;34m(classifiers, voting)\u001b[0m\n\u001b[0;32m     20\u001b[0m     \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Classifiers: \"\u001b[0m\u001b[1;33m+\u001b[0m\u001b[0min_use_classifiers\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     21\u001b[0m     \u001b[0mvoting\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mVotingClassifier\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mestimators\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0musableClassifier\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mvoting\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mvoting\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 22\u001b[1;33m     \u001b[0moverallClassificationReport\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mvoting\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mclasses\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[1;32m<ipython-input-54-ae2341149d5f>\u001b[0m in \u001b[0;36moverallClassificationReport\u001b[1;34m(model, classes)\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0moverallClassificationReport\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmodel\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mclasses\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m         \u001b[0mvisualizer\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mClassificationReport\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmodel\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mclasses\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mclasses\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0msupport\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mTrue\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;31m#might can change\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m         \u001b[0mvisualizer\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mfit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mX_train\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my_train\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mreshape\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m        \u001b[1;31m# Fit the visualizer and the model\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      4\u001b[0m         \u001b[0mvisualizer\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mscore\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mX_test\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my_test\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[1;33m)\u001b[0m        \u001b[1;31m# Evaluate the model on the test data\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m         \u001b[0mvisualizer\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshow\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'X_train' is not defined"
     ]
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ML",
   "language": "python",
   "name": "ml"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
